.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DBus::Test::MockMessage 3pm"
.TH Net::DBus::Test::MockMessage 3pm "2006-11-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::DBus::Test::MockMessage \- Fake a message object when unit testing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Sending a message
.PP
.Vb 2
\&  my $msg = new Net::DBus::Test::MockMessage;
\&  my $iterator = $msg\->iterator;
.Ve
.PP
.Vb 2
\&  $iterator\->append_byte(132);
\&  $iterator\->append_int32(14241);
.Ve
.PP
.Vb 1
\&  $connection\->send($msg);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a \*(L"mock\*(R" counterpart to the Net::DBus::Binding::Message
class. It is basically a pure Perl fake message object providing the same
contract as the real message object. It is intended for use internally by the
testing APIs.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $call\fR = Net::DBus::Test::MockMessage\->new_method_call( service_name => \f(CW$service\fR, object_path => \f(CW$object\fR, interface => \f(CW$interface\fR, method_name => \f(CW$name);" 4
.el .IP "my \f(CW$call\fR = Net::DBus::Test::MockMessage\->new_method_call( service_name => \f(CW$service\fR, object_path => \f(CW$object\fR, interface => \f(CW$interface\fR, method_name => \f(CW$name\fR);" 4
.IX Item "my $call = Net::DBus::Test::MockMessage->new_method_call( service_name => $service, object_path => $object, interface => $interface, method_name => $name);"
Create a message representing a call on the object located at
the path \f(CW\*(C`object_path\*(C'\fR within the client owning the well-known
name given by \f(CW\*(C`service_name\*(C'\fR. The method to be invoked has
the name \f(CW\*(C`method_name\*(C'\fR within the interface specified by the
\&\f(CW\*(C`interface\*(C'\fR parameter.
.ie n .IP "my $msg\fR = Net::DBus::Test::MockMessage\->new_method_return( replyto => \f(CW$method_call);" 4
.el .IP "my \f(CW$msg\fR = Net::DBus::Test::MockMessage\->new_method_return( replyto => \f(CW$method_call\fR);" 4
.IX Item "my $msg = Net::DBus::Test::MockMessage->new_method_return( replyto => $method_call);"
Create a message representing a reply to the method call passed in
the \f(CW\*(C`replyto\*(C'\fR parameter.
.ie n .IP "my $signal\fR = Net::DBus::Test::MockMessage\->new_signal( object_path => \f(CW$path\fR, interface => \f(CW$interface\fR, signal_name => \f(CW$name);" 4
.el .IP "my \f(CW$signal\fR = Net::DBus::Test::MockMessage\->new_signal( object_path => \f(CW$path\fR, interface => \f(CW$interface\fR, signal_name => \f(CW$name\fR);" 4
.IX Item "my $signal = Net::DBus::Test::MockMessage->new_signal( object_path => $path, interface => $interface, signal_name => $name);"
Creates a new message, representing a signal [to be] emitted by
the object located under the path given by the \f(CW\*(C`object_path\*(C'\fR
parameter. The name of the signal is given by the \f(CW\*(C`signal_name\*(C'\fR
parameter, and is scoped to the interface given by the
\&\f(CW\*(C`interface\*(C'\fR parameter.
.ie n .IP "my $msg\fR = Net::DBus::Test::MockMessage\->new_error( replyto => \f(CW$method_call\fR, name => \f(CW$name\fR, description => \f(CW$description);" 4
.el .IP "my \f(CW$msg\fR = Net::DBus::Test::MockMessage\->new_error( replyto => \f(CW$method_call\fR, name => \f(CW$name\fR, description => \f(CW$description\fR);" 4
.IX Item "my $msg = Net::DBus::Test::MockMessage->new_error( replyto => $method_call, name => $name, description => $description);"
Creates a new message, representing an error which occurred during
the handling of the method call object passed in as the \f(CW\*(C`replyto\*(C'\fR
parameter. The \f(CW\*(C`name\*(C'\fR parameter is the formal name of the error
condition, while the \f(CW\*(C`description\*(C'\fR is a short piece of text giving
more specific information on the error.
.ie n .IP "my $type\fR = \f(CW$msg\->get_type" 4
.el .IP "my \f(CW$type\fR = \f(CW$msg\fR\->get_type" 4
.IX Item "my $type = $msg->get_type"
Retrieves the type code for this message. The returned value corresponds
to one of the four \f(CW\*(C`Net::DBus::Test::MockMessage::MESSAGE_TYPE_*\*(C'\fR constants.
.ie n .IP "my $name\fR = \f(CW$msg\->get_error_name" 4
.el .IP "my \f(CW$name\fR = \f(CW$msg\fR\->get_error_name" 4
.IX Item "my $name = $msg->get_error_name"
Returns the formal name of the error, as previously passed in via
the \f(CW\*(C`name\*(C'\fR parameter in the constructor.
.ie n .IP "my $interface\fR = \f(CW$msg\->get_interface" 4
.el .IP "my \f(CW$interface\fR = \f(CW$msg\fR\->get_interface" 4
.IX Item "my $interface = $msg->get_interface"
Retrieves the name of the interface targetted by this message, possibly
an empty string if there is no applicable interface for this message.
.ie n .IP "my $path\fR = \f(CW$msg\->get_path" 4
.el .IP "my \f(CW$path\fR = \f(CW$msg\fR\->get_path" 4
.IX Item "my $path = $msg->get_path"
Retrieves the object path associated with the message, possibly an
empty string if there is no applicable object for this message.
.ie n .IP "my $name\fR = \f(CW$msg\->get_destination" 4
.el .IP "my \f(CW$name\fR = \f(CW$msg\fR\->get_destination" 4
.IX Item "my $name = $msg->get_destination"
Retrieves the uniqe or well-known bus name for client intended to be
the recipient of the message. Possibly returns an empty string if
the message is being broadcast to all clients.
.ie n .IP "my $name\fR = \f(CW$msg\->get_sender" 4
.el .IP "my \f(CW$name\fR = \f(CW$msg\fR\->get_sender" 4
.IX Item "my $name = $msg->get_sender"
Retireves the unique name of the client sending the message
.ie n .IP "my $serial\fR = \f(CW$msg\->get_serial" 4
.el .IP "my \f(CW$serial\fR = \f(CW$msg\fR\->get_serial" 4
.IX Item "my $serial = $msg->get_serial"
Retrieves the unique serial number of this message. The number
is guarenteed unique for as long as the connection over which
the message was sent remains open. May return zero, if the message
is yet to be sent.
.ie n .IP "my $name\fR = \f(CW$msg\->get_member" 4
.el .IP "my \f(CW$name\fR = \f(CW$msg\fR\->get_member" 4
.IX Item "my $name = $msg->get_member"
For method calls, retrieves the name of the method to be invoked,
while for signals, retrieves the name of the signal.
.IP "$msg\->set_sender($name)" 4
.IX Item "$msg->set_sender($name)"
Set the name of the client sending the message. The name must
be the unique name of the client.
.IP "$msg\->set_destination($name)" 4
.IX Item "$msg->set_destination($name)"
Set the name of the intended recipient of the message. This is
typically used for signals to switch them from broadcast to
unicast.
.ie n .IP "my $iterator\fR = \f(CW$msg\->iterator;" 4
.el .IP "my \f(CW$iterator\fR = \f(CW$msg\fR\->iterator;" 4
.IX Item "my $iterator = $msg->iterator;"
Retrieves an iterator which can be used for reading or
writing fields of the message. The returned object is
an instance of the \f(CW\*(C`Net::DBus::Binding::Iterator\*(C'\fR class.
.ie n .IP "$boolean = $msg\fR\->\fIget_no_reply()" 4
.el .IP "$boolean = \f(CW$msg\fR\->\fIget_no_reply()\fR" 4
.IX Item "$boolean = $msg->get_no_reply()"
Gets the flag indicating whether the message is expecting
a reply to be sent. 
.IP "$msg\->set_no_reply($boolean)" 4
.IX Item "$msg->set_no_reply($boolean)"
Toggles the flag indicating whether the message is expecting
a reply to be sent. All method call messages expect a reply
by default. By toggling this flag the communication latency
is reduced by removing the need for the client to wait
.ie n .IP "my @values\fR = \f(CW$msg\->get_args_list" 4
.el .IP "my \f(CW@values\fR = \f(CW$msg\fR\->get_args_list" 4
.IX Item "my @values = $msg->get_args_list"
De-marshall all the values in the body of the message, using the 
message signature to identify data types. The values are returned
as a list.
.IP "$msg\->append_args_list(@values)" 4
.IX Item "$msg->append_args_list(@values)"
Append a set of values to the body of the message. Values will
be encoded as either a string, list or dictionary as appropriate
to their Perl data type. For more specific data typing needs,
the Net::DBus::Binding::Iterator object should be used instead.
.ie n .IP "my $sig\fR = \f(CW$msg\->get_signature" 4
.el .IP "my \f(CW$sig\fR = \f(CW$msg\fR\->get_signature" 4
.IX Item "my $sig = $msg->get_signature"
Retrieves a string representing the type signature of the values
packed into the body of the message.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus::Binding::Message, Net::DBus::Test::MockConnection, Net::DBus::Test::MockIterator
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel Berrange <dan@berrange.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 by Daniel Berrange
